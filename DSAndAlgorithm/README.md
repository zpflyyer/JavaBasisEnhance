# 树
------

## 二叉树
### 1. 重要性质

 > 平均深度比节点个数要少很；
  二叉树的三种常见遍历的时间复杂度为O(n)；
  
------

### 2. 二叉搜索树
 1. 特点
 > 左子树上的所有节点比根节点小，根节点比右子树的所有节点小。且左右子树也分别是BST

 2. 插入
 > 递归地插入。在每个节点上，如果判断在其子树上插入，那么需要**返回插入新节点后的L/R子树的根来作为当前节点的相应子树指针的指向**，因为新插入节点最终是插入到一个空节点上的

 3. 删除
 > 递归地删除，和插入一样，如果操作是在子树上进行，那么子树删除了待删除节点后应该返回其根作为当前节点的相应子树指针的指向。且如果**待删除节点的双子树非空，那么需要递归地删除该节点的前驱节点或者后驱节点**

 4. 查找
 > **search**,**minimum**,**maximum**,**predecessor**,**successor复杂度均为O(h)**，其中h为其深度；
  **极端情形下会退化为线性链表**，此时的复杂度为O(n)
 
 5. 后继节点查找伪代码
    ```java
     if(root.right != null){
        return findMinimum(root.left);
     }
     Node<T> = root.parent;
     /*
     如果root没有右子树，那么root如果是其父亲的左孩子，其父亲就是其后继节点，否则其父亲是其前驱节点，需要递归向上，直至找到一个节点，以查找路径里的上一个节点为左孩子的节点。
     */
     if (p != null && p.right == root){ 
        root = p;
        p = p.parent;
     }
     return p;
    ```
  
------

### 3.AVL树：

 - 含义
 > 带有平衡条件的BST，即任何节点的**左右子树高度差不得超过1**，从而保证了性能接近O(logN)

 - 插入引起的不平衡情形分析
 > 从插入的节点开始，自底向上寻找第一个不满足平衡性条件的节点T，该子树必然是因为其两棵子树C1，C2高度原本相差1，而插入正好发生在原本较高的那棵子树上(假设为C1)，才会导致不平衡情形出现。进一步分析，原本较高的那棵子树C1的两棵子树G1,G2的高度必然是相等的。因为一棵树的高度变化，必然是由其最高的子树高度变化引起的。因此如果C1的两棵子树高度原本就不一致的话，那么由于插入后C1高度增加了1，所以必然是C1的较高的子树（假设为G1)发生了插入且高度加1，而这样一来，C1就成了比T更接近插入元素的不平衡节点了；
因此，**从插入元素开始自底向上寻找到的第一个不平衡节点T必然满足两棵子树C1，C2原本就高度不一致且插入前较高子树到到插入节点的路径上每个节点的左右子树的高相等的性质**；
并且，单旋转和双旋转的模型也就确定出来了，且可以很容易证明通过最多两次旋转后，T的高度不变。因此**插入引起的AVL树的不平衡仅需要一次再平衡操作**

 - 单旋转
   待调整结构：N，N+M,N+M+P构成的**\\**状（\上的三个连续节点）
   目的：的中间元素N+M升级为根替换N,从而N+M+P子树高度插入后不变

 - 双旋转
   待调整结构：调整N，N+M,N+M+P构成的**>**状
   第一步单旋转：将N+M+P调整到N+M的右子树上去，得到N,N+M,N+M+P构成的**\\**状
   第二部单旋转：和单旋转就能解决的情形一样

 - 记录节点高度维护平衡信息
 递归地平衡子树。每个子树上执行完插入后，需要对该子树进行再平衡。再平衡包括两个工作：
   - 检查更新节点高度信息
   - 检查并进行旋转操作
> 值得注意的是，插入未必会引起不平衡，但是一定会引起插入路径上某些节点的高度变化。**高度调整会从插入节点自底向上进行，直到某个节点高度相比插入前不变或者直至根节点才会结束**。而寻找到第一个不平衡节点并进行再平衡，之后该节点的高度不变，因此**插入再平衡的发生属于高度调整结束的一种特殊情形**。实际中，**插入后并不总是引起不平衡**，即以不做任何再平衡操作的情形结束；
因此，**平衡函数需要先检查并进行可能的旋转操作，然后重新计算节点高度，即使不发生旋转也要重新计算高度**；
**也可以先计算节点高度再进行旋转操作，只是这样一来，之前计算的高度就会失效，需要旋转函数负责再次更新不平衡节点的高度。**
 -  AVL树节点删除
  -  **删除相比插入有一种特有的情形：即删除后不平衡因子T的较高的子树C1的两个儿子G1，G2高度一致**。这种情形下，执行单旋转依然有效。
  -  **AVL树的删除后将首个不平衡因子调整后，其高度可能会下降1。因此删除算法最坏情形下需要进行O(logN)次平衡调整，即一直进行到根节点**
  
------

### 4. 伸展树 splaying tree

 - **摊还代价为O(logN)**
 > 分析：不存在坏的输入情况，即一系列访问深度都很深的情形很罕见；
维护：根据**principle of locality**，一旦一个访问代价很大的节点被访问，那么其很可能还会随后被再次访问，并且其临近的节点也可能会被访问。因此，这样的节点（访问路径长）被访问后必须进行调整以使得**其本身及其邻近节点的深度明显下降**
 具体的旋转分为**zig-zag**（双旋转）和**zig-zig**两种情形（**先由祖父绕着父亲旋，之后父亲绕着该节点旋**）
  
------
### 5. B树

 - 含义
 > 一种多路树，相比二叉树高度更低，因此访问树节点的次数更少。特别是数据量很大，而节点大多数都在磁盘上的时候，系统的性能几乎全部取决于磁盘读取速度。所以，减少访问磁盘的次数是很重要的，可以一次性读取一个较大的快，用更多的CPU计算去换取更少的磁盘读取，是绝对划算的。

 - 平衡性条件
 > 需要**避免退化为更低路树**

 - B+树
 > B+树仅在叶子节点上存储数据，而**非叶子节点上存储的都是size比数据记录更小的关键字**，这样一来，每个节点字节数一定的情况下，**B+树相比B树能够存储更多的关键字**，即多路树的路数可以更多
 
 - **B+树需要满足的平衡性条件**
    - M叉二叉树每个节点由最多M-1个关键字指示搜索方向，关键字i表示子树i+1中的最小关键字
    > `(M-1) = SizeOfNode / SizeOfKey`

    - 根节点子树允许范围为[2,M],其他非叶子节点允许的子树范围为[⌈M/2⌉,M]
    - 叶子节点的元素个数允许取值范围为[⌈L/2⌉,L]
    > `L = SizeOfNode / SizeOfItem`
 
 - B+树的平衡性条件解释和插入时维持
 
   - 每次插入新记录，需要定位插入位置，然后插入到某个叶子节点上，但是如果该叶子节点满了，那么可以分裂该叶子节点从而使得叶子的父亲多了一个子树，这可能引起父亲节点超出M个，从而父亲节点也需要分裂，但是概率很低。或者当相邻叶子节点有空间时，将多的元素交给其他叶子节点领养，从而使得**B+树更满，长时间运行更加节省空间和获得更高的访问效率**
   - 平均L/2次非分裂插入才会引起一次分裂
   - 经过很多次分裂，可能会导致根节点的分裂，此时需要一个新的根连接两个破裂的旧根，这就是为什么根节点的子树个数允许为2的情形，也是B+树高度上升的唯一方式
  
 - B+树的删除
   - 每次删除记录，可能会导致叶子不满，从而需要向邻接叶子领养记录，如果领养不到，那么可能就需要进行合并操作，经过很多合并，根可能会只剩下一个子树，此时子树的根代替原来的根。这是B+树高度下降的唯一方式
   - 不允许子节点空闲超过一半的意思是：如果出现这样的节点，那需要将其和别的节点合并
  
-----

### 6. 红黑树
 - 约束条件：
    - 所有节点非红即黑
    - **根节点总是黑色，且null节点总视为黑色** 🤭嘿-------嘿
    - 任一路径上**不允许出现连续的红色节点**
    - 每个节点到其所有叶子节点的路径上的黑色节点个数相等，这个个数也称为**黑高bh(x)**
 
 - 性质1：红黑树的高度h和其内部节点个数n满足：h <= 2*log<sub>2</sub>(n+1)

    又因为对于任何二叉树满足：h >= log<sub>2</sub>(n+1)
    
    综上，具有n个节点的红黑树的高度满足：
        
    **h(n) = &Theta;(log<sub>2</sub>(n))**
    
  - 插入再平衡算法：
  
    - 再平衡以若干次重新着色（z高度每次上升2）而结束，如果连根节点也被着色，则需要注意根的颜色可能会被着色为红色，需要在最后将根设置为黑色；
    - 也可能在若干次着色之后，通过1到2次旋转（第一次旋转会导致z和p指针父子角色发生交换，需要在旋转后更改z、p指针的指向；第二次旋转的同时，需要交换旋转点和其转中心的颜色）而结束，这时候不存在根的颜色被着色为红色的情形，但是有可能整棵树的root节点发生改变
